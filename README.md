# Implementation for the thesis "practical graph coloring algorithms" by Gitte Van Orshoven

This repository holds the implementation, graphs, and data used for the thesis "practical graph coloring algorithms" made in the context of the Master in Engineering: Computer Science study at the KU Leuven.

### Bruteforce implementation
* bounds.c: implementation for the different upper bounds of the chromatic number
* bruteforce.c: file with the starting point (main function) for the bruteforce algorithm
* coloring.c: implementation of the bruteforce approach to find a proper vertex coloring for the graph
* graph.c: data representation of the graph as well as implementations to read a graph from an input file
* heuristics.c: all functionality for selecting the next vertex to be colored (and a color to color the vertex) according to the sorting heuristics
* low-k.c specialized implementation for k-colorings for low values (2, 3, or 4) of k
* search.c: implementation of the different search methods
* HOW TO RUN: compile the bruteforce.c file with the -lm flag (the other listed files need to be present in the same directory), run the compiled program with the following arguments:
  * (relative or absolute) path to the file of the graph
  * number of vertices of the graph
  * (in case of k-coloring) the maximal number of colors allowed
  * Example:
    * gcc -O3 bruteforce.c -lm -o bruteforce
    * ./bruteforce graph.col 10 3

### Dynamic programming
* dynamic_programming.c

### Data
The file "data.ods" holds all the data generated by the benchmarks. The following sheets are present in the file:
* Benchmark Graphs and Sets: all the graphs used for benchmarking along with their characteristics categorization into different sets.
* KCOLORING: Execution times for computing k-colorings for different values of k relative to X(G). 
  Comparison for k-colorings with low values of k between standard bruteforce approach and a specialized algorithm. 
  Large set of execution times for X(G)-1 colorings and X(G) colorings in function of |V|.
* VERTEX: ET, BE, EF, and EF' for the benchmark graphs when using the VERTEX heuristic for both a connected sequential ordering and no connected sequential ordering.
  Tables for the categorization bounds.
* DEGREE: ET, BE, EF, and EF' for the benchmark graphs when using the DEGREE heuristic for both a connected sequential ordering and no connected sequential ordering.
  Tables for the categorization bounds.
* IDO: ET, BE, EF, and EF' for the benchmark graphs when using the IDO heuristic for different values {0,1,...,8} of the SORTING_RATE.
  Tables for the categorization bounds.
* DSATUR: ET, BE, EF, and EF' for the benchmark graphs when using the DSATUR heuristic for different values {0,1,...,8} of the SORTING_RATE.
  Tables for the categorization bounds.
* RECOLOR_DECAY: ET, BE, EF, and EF' for the benchmark graphs when using the RECOLOR heuristic for SORTING_RATE 1 and no CS for different values {0.00,0.05,...,1.50} of the DECAY_FACTOR.
  Tables for the categorization bounds.
* RECOLOR: ET, BE, EF, and EF' for the benchmark graphs when using the RECOLOR heuristic for different values {0,1,...,8} of the SORTING_RATE and both CS and no CS.
  Tables for the categorization bounds.
* CONFLICT_DECAY: ET, BE, EF, and EF' for the benchmark graphs when using the CONFLICT heuristic for SORTING_RATE 1 and no CS for different values {0.00,0.05,...,1.50} of the DECAY_FACTOR.
  Tables for the categorization bounds.
* CONFLICT: ET, BE, EF, and EF' for the benchmark graphs when using the CONFLICT heuristic for different values {0,1,...,8} of the SORTING_RATE and both CS and no CS.
  Tables for the categorization bounds.
* SORTING: ET, BE, EF, and EF' for the benchmark graphs when using different sorting heuristics.
  Tables for the categorization bounds.
* BINARY: ET, BE, EF, and EF' for the benchmark graphs when executing a BINARY search for different methods for the upper bound.
  Tables for the categorization bounds.
* GREBIN: ET, BE, EF, and EF' for the benchmark graphs when executing a GREBIN search for different methods for the upper bound.
  Tables for the categorization bounds.
* EXHAUSTIVE: ET, BE, EF, and EF' for the benchmark graphs when executing an EXHAUSTIVE search for different methods for the upper bound.
  Tables for the categorization bounds.
* SEARCH: ET, BE, EF, and EF' for the benchmark graphs for different search methods.
  Tables for the categorization bounds.
* STATIC-SORTING: ET, BE, EF, and EF' for the benchmark graphs for different sorting heuristics when using a static configuration.
* STATIC-SEARCH: ET, BE, EF, and EF' for the benchmark graphs for different search methods when using a static configuration.
* STATIC-DYNAMIC: ET, BE, EF, and EF' for the benchmark graphs for the static configuration and the automatic algorithm configuration.

### Graphs in the benchmark
The graphs in the directory "graphs_benchmark" are the graphs listed in appendix D and used for all the benchmarking.

### Graphs used for the creation of figure 6.4
The graphs in the directory "graphs_HOG" are the graphs listed in appendix F and are used for the generation of figure 6.4.
